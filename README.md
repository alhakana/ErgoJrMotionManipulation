# ğŸš€ ErgoJr Motion Manipulation â€” IK Circular Motion Demo

## ğŸ“Œ Overview

This project demonstrates **inverse kinematics based motion manipulation** of the **ErgoJr robotic arm** inside **CoppeliaSim**.

The robot performs controlled end-effector motion by:

- generating a circular trajectory in 3D space  
- discretizing the circle into 7 points
- moving the IK target between nearest left/right neighbors  
- holding each position for a fixed duration  
- using IK to automatically reposition the robot joints so that the end-effector follows the desired trajectory  

The goal of this project is to explore:

- inverse kinematics workflows in CoppeliaSim  
- motion generation in Cartesian space  
- interaction between dynamic joint motors and IK control  
- geometric trajectory planning  

---

## ğŸ¥ Simulation Demo

ğŸ“¹ **[Simulation video](https://drive.google.com/file/d/1-w6EIuPZczw8It_tyWcOajdP_gzVRqbD/view?usp=share_link)**  

---

## ğŸ¦¾ Robot Model

The robotic arm used in this project is:

- **ErgoJr**
- model obtained from the official Poppy documentation
- simulated inside CoppeliaSim EDU

Main components:

- IK_target  
- IK_tip  
- automatically generated IK object  
- 6 revolute joints (m1 â†’ m6)  
- dynamic joint motors controlled through position mode  

---

## âš™ï¸ How It Works

### 1ï¸âƒ£ Trajectory Generation

The trajectory is defined as:

- a circle in the **world XZ plane**
- centered at the initial position of lamp_visual
- with configurable radius
```
X = cx + r cos(a)  
Y = constant  
Z = cz + r sin(a)
```
The circle is discretized into:
```
numPoints = 7
```
Each point represents a reachable Cartesian target.

---

### 2ï¸âƒ£ Motion Logic

During simulation:

1. Random start point is selected  
2. The robot stays at each point for:
```
holdTime = 3 
```
3. The next point is selected randomly:

- nearest left OR  
- nearest right  

This produces non-deterministic but constrained motion around the circle.

---

### 3ï¸âƒ£ Inverse Kinematics

CoppeliaSim IK Generator automatically creates:

- IK environment  
- IK group  
- constraint chain:
```
Base â†’ Tip â†’ Target
```
When the target moves:

- IK solver computes required joint angles  
- joint motors move the robot  
- end-effector (```IK_tip```) follows the trajectory  

---

## ğŸ§  Key Implementation Details

### Joint Motors

Dynamic motors are enabled to prevent the robot from collapsing under gravity:
```
sim.setJointMode(..., sim.jointmode_force)  
sim.setObjectInt32Param(... motor_enabled ...)  
sim.setObjectInt32Param(... ctrl_enabled ...)
```
---

### Trajectory Center

The circle center is computed from:
```
center = sim.getObjectPosition(lamp_visual, -1)
```
and slightly shifted along the Y-axis to keep the trajectory reachable.

---

## ğŸ§© Project Structure
```
ErgoJr  
â”œâ”€â”€ IK_target  
â”œâ”€â”€ IK_tip  
â”œâ”€â”€ IK  
â”œâ”€â”€ script (motion logic)  
â””â”€â”€ robot links & joints
```
Main scripts:

- **Motion Script** â€” trajectory generation & target switching  
- **IK Generator Script** â€” auto-generated by CoppeliaSim  

---

## â–¶ï¸ Running the Simulation

1. Open the scene in **CoppeliaSim**  
2. Ensure:
   - IK object is enabled  
   - joints are dynamic  
   - motors are enabled  
3. Press **Play**  

The robot will start moving the end-effector across circular points.

---

## ğŸ”¬ What We Learned

This project explores practical robotics concepts:

- Cartesian vs joint-space control  
- IK solver behavior and stability  
- reachability constraints  
- dynamic vs kinematic simulation  
- trajectory discretization  

---

## ğŸ‘©â€ğŸ’» Authors

Project developed collaboratively by:

- Alya Al Hakan  
- AnÄ‘elija MladenoviÄ‡

---

## ğŸ·ï¸ Tech Stack


- CoppeliaSim
- Lua
- simIK
- Inverse Kinematics
- Dynamics simulation
